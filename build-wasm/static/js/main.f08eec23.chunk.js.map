{"version":3,"sources":["components/MandelbrotVisualizer/MandelbrotVisualizer.module.css","components/RenderOptions/RenderOptions.module.css","components/MandelbrotVisualizer/utils/sleep.ts","components/RegionSelectableCanvas/utils/CanvasBackup.ts","components/RegionSelectableCanvas/RegionSelectableCanvas.tsx","MandelbrotSet/infrastructure/MandelbrotSetWasm/MandelbrotSetWasm.ts","components/MandelbrotVisualizer/MandelbrotVisualizer.tsx","components/RenderOptions/RenderOptions.tsx","serviceWorker.ts","index.tsx","components/App/App.tsx"],"names":["module","exports","sleep","ms","Promise","r","setTimeout","CanvasBackup","originalCanvas","originalCanvasCtx","backupCanvas","backupCanvasCtx","this","getContext","setupBackupCanvas","document","createElement","width","height","drawImage","RegionSelectableCanvas","props","canvas","canvasCtx","canvasBackup","canvasRatio","originX","originY","mouseX","mouseY","selectedAreaStartX","selectedAreaEndX","selectedAreaStartY","selectedAreaEndY","mouseIsDown","onRef","innerRef","handleMouseDown","e","pageX","pageY","save","handleMouseUp","onChangeSelectedRegion","handleMouseMove","calculateSelectionArea","restore","drawRawRect","drawFixedRect","xWidth","yWidth","xPreservingAspectRatioWidth","Math","min","yPreservingAspectRatioHeight","offsetX","offsetY","finalWidth","finalHeight","drawRect","color","startX","endX","startY","endY","strokeStyle","strokeRect","ref","window","innerWidth","innerHeight","className","onMouseDown","onMouseUp","onMouseMove","Component","MandelbrotSetWasm","wasmInstance","importPromise","then","MandelbrotSet","Boolean","isInitialized","initialized","min_corner_a","min_corner_b","max_corner_a","max_corner_b","startXPx","endXPx","startYPx","endYPx","zoom_canvas","maxIterations","render","MandelbrotVisualizer","mandelbrotSet","refreshCanvas","zoomCanvas","previousProps","renderingKey","minCornerA","minCornerB","maxCornerA","maxCornerB","onChangeBounds","clamped","imageData","ImageData","putImageData","classes","RenderOptions","onChangeMaxIterations","corners","refresh","container","onSubmit","preventDefault","type","value","onChange","parseInt","target","location","hostname","match","ReactDOM","useState","setMaxIterations","random","setRenderingKey","setCorners","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f08eec23.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"MandelbrotVisualizer_canvas__hswg-\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"RenderOptions_container__U4epK\"};","export const sleep = (ms: number) => new Promise(r => setTimeout(r, ms))\n","export class CanvasBackup {\n  private originalCanvas: HTMLCanvasElement\n  private originalCanvasCtx: CanvasRenderingContext2D \n  private backupCanvas: HTMLCanvasElement\n  private backupCanvasCtx: CanvasRenderingContext2D \n\n  constructor(originalCanvas: HTMLCanvasElement) {\n    this.originalCanvas = originalCanvas;\n    this.originalCanvasCtx = originalCanvas.getContext('2d') as CanvasRenderingContext2D;\n    \n    this.backupCanvas = this.setupBackupCanvas();\n    this.backupCanvasCtx = this.backupCanvas.getContext('2d') as CanvasRenderingContext2D;\n  }\n\n  setupBackupCanvas() {\n    const backupCanvas = document.createElement('canvas');\n    backupCanvas.width = this.originalCanvas.width;\n    backupCanvas.height = this.originalCanvas.height;\n    return backupCanvas;\n  }\n\n  save() {\n    this.backupCanvasCtx.drawImage(this.originalCanvas, 0, 0);\n  }\n\n  restore() {\n    this.originalCanvasCtx.drawImage(this.backupCanvas, 0, 0);\n  }\n}\n","import React, { Component } from \"react\"\n\nimport { CanvasBackup } from \"./utils/CanvasBackup\"\n\ninterface RegionSelectableCanvasProps {\n  innerRef: (element: HTMLCanvasElement) => void\n  onChangeSelectedRegion: (\n    selectedAreaStartX: number,\n    selectedAreaEndX: number,\n    selectedAreaStartY: number,\n    selectedAreaEndY: number,\n  ) => void\n  className: string\n}\n\nexport class RegionSelectableCanvas extends Component<\n  RegionSelectableCanvasProps\n> {\n  private canvas: HTMLCanvasElement\n  private canvasCtx: CanvasRenderingContext2D\n  private canvasBackup: CanvasBackup\n  private canvasRatio: number\n\n  private originX: number\n  private originY: number\n  private mouseX: number\n  private mouseY: number\n\n  private selectedAreaStartX: number\n  private selectedAreaEndX: number\n  private selectedAreaStartY: number\n  private selectedAreaEndY: number\n\n  private mouseIsDown: boolean\n\n  onRef = (canvas: HTMLCanvasElement) => {\n    this.canvas = canvas\n    this.canvasCtx = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D\n    this.canvasBackup = new CanvasBackup(this.canvas)\n    this.canvasRatio = this.canvas.height / this.canvas.width\n\n    this.props.innerRef(canvas)\n  }\n\n  constructor(props: any) {\n    super(props)\n    this.canvas = (null as any) as HTMLCanvasElement\n    this.canvasCtx = (null as any) as CanvasRenderingContext2D\n    this.canvasBackup = (null as any) as CanvasBackup\n    this.canvasRatio = (null as any) as number\n    this.originX = 0\n    this.originY = 0\n    this.mouseX = 0\n    this.mouseY = 0\n    this.selectedAreaStartX = 0\n    this.selectedAreaEndX = 0\n    this.selectedAreaStartY = 0\n    this.selectedAreaEndY = 0\n    this.mouseIsDown = false\n  }\n\n  handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    this.mouseIsDown = true\n    this.originX = e.pageX\n    this.originY = e.pageY\n\n    this.canvasBackup.save()\n  }\n\n  handleMouseUp = () => {\n    this.mouseIsDown = false\n    this.props.onChangeSelectedRegion(\n      this.selectedAreaStartX,\n      this.selectedAreaEndX,\n      this.selectedAreaStartY,\n      this.selectedAreaEndY,\n    )\n  }\n\n  calculateSelectionArea() {\n    const xWidth = this.mouseX - this.originX\n    const yWidth = this.mouseY - this.originY\n\n    const xPreservingAspectRatioWidth = Math.min(\n      xWidth,\n      yWidth / this.canvasRatio,\n    )\n    const yPreservingAspectRatioHeight = Math.min(\n      yWidth,\n      xWidth * this.canvasRatio,\n    )\n\n    const offsetX = (xWidth - xPreservingAspectRatioWidth) / 2\n    const offsetY = (yWidth - yPreservingAspectRatioHeight) / 2\n\n    const finalWidth = xPreservingAspectRatioWidth\n    const finalHeight = yPreservingAspectRatioHeight\n\n    this.selectedAreaStartX = this.originX + offsetX\n    this.selectedAreaStartY = this.originY + offsetY\n    this.selectedAreaEndX = this.selectedAreaStartX + finalWidth\n    this.selectedAreaEndY = this.selectedAreaStartY + finalHeight\n  }\n\n  handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (this.mouseIsDown) {\n      this.mouseX = e.pageX\n      this.mouseY = e.pageY\n\n      this.calculateSelectionArea()\n      this.canvasBackup.restore()\n      this.drawRawRect()\n      this.drawFixedRect()\n    }\n  }\n\n  drawRawRect() {\n    this.drawRect(\n      \"#00FF00\",\n      this.originX,\n      this.mouseX,\n      this.originY,\n      this.mouseY,\n    )\n  }\n\n  drawFixedRect() {\n    this.drawRect(\n      \"#FF0000\",\n      this.selectedAreaStartX,\n      this.selectedAreaEndX,\n      this.selectedAreaStartY,\n      this.selectedAreaEndY,\n    )\n  }\n\n  drawRect(\n    color: string,\n    startX: number,\n    endX: number,\n    startY: number,\n    endY: number,\n  ) {\n    this.canvasCtx.strokeStyle = color\n    this.canvasCtx.strokeRect(startX, startY, endX - startX, endY - startY)\n  }\n\n  render() {\n    return (\n      <canvas\n        ref={this.onRef}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        className={this.props.className}\n        onMouseDown={this.handleMouseDown}\n        onMouseUp={this.handleMouseUp}\n        onMouseMove={this.handleMouseMove}\n      />\n    )\n  }\n}\n","import { IMandelbrotSet } from \"../../domain/MandelbrotSet\"\nimport { MandelbrotSet } from \"./pkg\"\n\nexport class MandelbrotSetWasm implements IMandelbrotSet {\n  private wasmInstance: MandelbrotSet\n  private importPromise: Promise<any>\n\n  constructor(width: number, height: number) {\n    this.wasmInstance = null as any\n    this.importPromise = import(\"./pkg\").then(({ MandelbrotSet }) => {\n      this.wasmInstance = new MandelbrotSet(width, height)\n    })\n  }\n\n  private isInitialized() {\n    return Boolean(this.wasmInstance)\n  }\n\n  private async initialized() {\n    if (this.isInitialized()) {\n      return\n    }\n    await this.importPromise\n  }\n\n  public async minCornerA() {\n    await this.initialized()\n    return this.wasmInstance.min_corner_a()\n  }\n  public async minCornerB() {\n    await this.initialized()\n\n    return this.wasmInstance.min_corner_b()\n  }\n  public async maxCornerA() {\n    await this.initialized()\n\n    return this.wasmInstance.max_corner_a()\n  }\n  public async maxCornerB() {\n    await this.initialized()\n    return this.wasmInstance.max_corner_b()\n  }\n\n  async zoomCanvas(startXPx: number, endXPx: number, startYPx: number, endYPx: number) {\n    await this.initialized()\n    this.wasmInstance.zoom_canvas(startXPx, endXPx, startYPx, endYPx)\n  }\n\n  async render(maxIterations = 100): Promise<Uint8ClampedArray> {\n    await this.initialized()\n    return this.wasmInstance.render(maxIterations)\n  }\n}\n","import React, { Component } from \"react\"\n\nimport { sleep } from \"./utils/sleep\"\nimport { RegionSelectableCanvas } from \"../RegionSelectableCanvas/RegionSelectableCanvas\"\nimport { IMandelbrotSet } from \"../../MandelbrotSet/domain/MandelbrotSet\"\nimport { MandelbrotSetWasm } from \"../../MandelbrotSet/infrastructure/MandelbrotSetWasm/MandelbrotSetWasm\"\nimport { MandelbrotSetTypescript } from \"../../MandelbrotSet/infrastructure/MandelbrotSetTypescript/MandelbrotSetTypescript\"\n\nimport classes from \"./MandelbrotVisualizer.module.css\"\n\ntype Corners = {\n  minCornerA: string\n  minCornerB: string\n  maxCornerA: string\n  maxCornerB: string\n}\n\ntype MandelbrotVisualizerProps = {\n  maxIterations: number\n  renderingKey: number\n  onChangeBounds: (corners: Corners) => void\n}\n\nexport class MandelbrotVisualizer extends Component<MandelbrotVisualizerProps> {\n  private mandelbrotSet: IMandelbrotSet\n  private canvas: HTMLCanvasElement\n  private canvasCtx: CanvasRenderingContext2D\n\n  constructor(props: any) {\n    super(props)\n\n    this.mandelbrotSet = (null as any) as IMandelbrotSet\n    this.canvasCtx = (null as any) as CanvasRenderingContext2D\n    this.canvas = (null as any) as HTMLCanvasElement\n  }\n\n  componentDidUpdate(previousProps: MandelbrotVisualizerProps) {\n    if (previousProps.renderingKey !== this.props.renderingKey) {\n      this.refreshCanvas()\n    }\n  }\n\n  onRef = (canvas: HTMLCanvasElement) => {\n    this.canvas = canvas\n    this.canvasCtx = canvas.getContext(\"2d\") as CanvasRenderingContext2D\n    this.mandelbrotSet = new MandelbrotSetWasm(canvas.width, canvas.height)\n    this.refreshCanvas()\n  }\n\n  private onChangeSelectedRegion = (\n    startXPx: number,\n    endXPx: number,\n    startYPx: number,\n    endYPx: number,\n  ) => {\n    this.mandelbrotSet.zoomCanvas(startXPx, endXPx, startYPx, endYPx).then(() => {\n      this.refreshCanvas()\n    })\n  }\n\n  private async refreshCanvas() {\n    this.props.onChangeBounds({\n      minCornerA: await this.mandelbrotSet.minCornerA(),\n      minCornerB: await this.mandelbrotSet.minCornerB(),\n      maxCornerA: await this.mandelbrotSet.maxCornerA(),\n      maxCornerB: await this.mandelbrotSet.maxCornerB(),\n    })\n    await sleep(50)\n\n    const clamped: Uint8ClampedArray = await this.mandelbrotSet.render(this.props.maxIterations)\n    const imageData = new ImageData(clamped, this.canvas.width, this.canvas.height)\n    this.canvasCtx.putImageData(imageData, 0, 0)\n  }\n\n  render() {\n    return (\n      <RegionSelectableCanvas\n        innerRef={this.onRef}\n        className={classes.canvas}\n        onChangeSelectedRegion={this.onChangeSelectedRegion}\n      />\n    )\n  }\n}\n","import React, { FC } from \"react\"\n\nimport classes from \"./RenderOptions.module.css\"\n\ninterface RenderOptionsProps {\n  onChangeMaxIterations: (maxIterations: number) => void\n  maxIterations: number\n  corners: {\n    minCornerA: string\n    minCornerB: string\n    maxCornerA: string\n    maxCornerB: string\n  }\n  refresh: () => void\n}\n\nexport const RenderOptions: FC<RenderOptionsProps> = ({\n  onChangeMaxIterations,\n  maxIterations,\n  corners,\n  refresh,\n}) => (\n  <form\n    className={classes.container}\n    onSubmit={e => {\n      e.preventDefault()\n      refresh()\n    }}\n  >\n    <div>\n      <input type=\"text\" value={corners.minCornerA} />\n      <input type=\"text\" value={corners.minCornerB} />\n    </div>\n    <div>\n      <input type=\"text\" value={corners.maxCornerA} />\n      <input type=\"text\" value={corners.maxCornerB} />\n    </div>\n    <input\n      type=\"number\"\n      onChange={e => onChangeMaxIterations(parseInt(e.target.value))}\n      value={maxIterations}\n    />\n    <input type=\"submit\" value=\"Refresh\" />\n  </form>\n)\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"./index.css\"\nimport { App } from \"./components/App/App\"\nimport * as serviceWorker from \"./serviceWorker\"\n\nReactDOM.render(<App />, document.getElementById(\"root\"))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n","import React, { FC, useState } from \"react\"\nimport { MandelbrotVisualizer } from \"../MandelbrotVisualizer/MandelbrotVisualizer\"\nimport { RenderOptions } from \"../RenderOptions/RenderOptions\"\n\nexport const App: FC = () => {\n  const [maxIterations, setMaxIterations] = useState(100)\n  const [renderingKey, setRenderingKey] = useState(Math.random())\n  const [corners, setCorners] = useState({\n    minCornerA: \"\",\n    minCornerB: \"\",\n    maxCornerA: \"\",\n    maxCornerB: \"\",\n  })\n\n  return (\n    <div>\n      <MandelbrotVisualizer\n        renderingKey={renderingKey}\n        maxIterations={maxIterations}\n        onChangeBounds={setCorners}\n      />\n      <RenderOptions\n        onChangeMaxIterations={setMaxIterations}\n        maxIterations={maxIterations}\n        refresh={() => setRenderingKey(Math.random())}\n        corners={corners}\n      />\n    </div>\n  )\n}\n"],"sourceRoot":""}
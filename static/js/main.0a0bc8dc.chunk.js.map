{"version":3,"sources":["components/MandelbrotVisualizer/MandelbrotVisualizer.module.css","components/RenderOptions/RenderOptions.module.css","components/RegionSelectableCanvas/utils/CanvasBackup.ts","components/RegionSelectableCanvas/RegionSelectableCanvas.tsx","components/MandelbrotVisualizer/utils/sleep.ts","components/MandelbrotVisualizer/MandelbrotVisualizer.tsx","components/RenderOptions/RenderOptions.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","canvas","container","CanvasBackup","originalCanvas","Object","classCallCheck","this","originalCanvasCtx","getContext","backupCanvas","setupBackupCanvas","backupCanvasCtx","createClass","key","value","document","createElement","width","height","drawImage","RegionSelectableCanvas","props","_this","possibleConstructorReturn","getPrototypeOf","call","onRef","canvasCtx","canvasBackup","canvasRatio","innerRef","handleMouseDown","e","mouseIsDown","originX","pageX","originY","pageY","save","handleMouseUp","onChangeSelectedRegion","selectedAreaStartX","selectedAreaEndX","selectedAreaStartY","selectedAreaEndY","handleMouseMove","mouseX","mouseY","calculateSelectionArea","restore","drawRawRect","drawFixedRect","xWidth","yWidth","xPreservingAspectRatioWidth","Math","min","yPreservingAspectRatioHeight","offsetX","offsetY","finalWidth","finalHeight","drawRect","color","startX","endX","startY","endY","strokeStyle","strokeRect","react_default","a","id","ref","window","innerWidth","innerHeight","className","onMouseDown","onMouseUp","onMouseMove","Component","sleep","ms","Promise","r","setTimeout","MandelbrotModule","__webpack_require__","then","bind","MandelbrotVisualizer","_ref","MandelbrotSet","mandelbrotSet","refreshCanvas","startXPx","endXPx","startYPx","endYPx","zoom_canvas","previousProps","renderingKey","onChangeBounds","min_corner_a","min_corner_b","max_corner_a","max_corner_b","console","time","render","maxIterations","timeEnd","components_RegionSelectableCanvas_RegionSelectableCanvas","classes","RenderOptions","onChangeMaxIterations","minCornerA","minCornerB","maxCornerA","maxCornerB","refresh","react","onSubmit","preventDefault","type","onChange","parseInt","target","App","state","random","setState","_this2","components_MandelbrotVisualizer_MandelbrotVisualizer","RenderOptions_RenderOptions","Boolean","location","hostname","match","ReactDOM","components_App","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.0a0bc8dc.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"MandelbrotVisualizer_canvas__cViT5\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"RenderOptions_container__116cG\"};","export class CanvasBackup {\r\n  private originalCanvas: HTMLCanvasElement\r\n  private originalCanvasCtx: CanvasRenderingContext2D \r\n  private backupCanvas: HTMLCanvasElement\r\n  private backupCanvasCtx: CanvasRenderingContext2D \r\n\r\n  constructor(originalCanvas: HTMLCanvasElement) {\r\n    this.originalCanvas = originalCanvas;\r\n    this.originalCanvasCtx = originalCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n    \r\n    this.backupCanvas = this.setupBackupCanvas();\r\n    this.backupCanvasCtx = this.backupCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n  }\r\n\r\n  setupBackupCanvas() {\r\n    const backupCanvas = document.createElement('canvas');\r\n    backupCanvas.width = this.originalCanvas.width;\r\n    backupCanvas.height = this.originalCanvas.height;\r\n    return backupCanvas;\r\n  }\r\n\r\n  save() {\r\n    this.backupCanvasCtx.drawImage(this.originalCanvas, 0, 0);\r\n  }\r\n\r\n  restore() {\r\n    this.originalCanvasCtx.drawImage(this.backupCanvas, 0, 0);\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\nimport { CanvasBackup } from \"./utils/CanvasBackup\";\r\n\r\ninterface RegionSelectableCanvasProps {\r\n  innerRef: (element: HTMLCanvasElement) => void\r\n  onChangeSelectedRegion: (\r\n    selectedAreaStartX: number,\r\n    selectedAreaEndX: number,\r\n    selectedAreaStartY: number,\r\n    selectedAreaEndY: number,\r\n  ) => void\r\n  className: string\r\n}\r\n\r\nclass RegionSelectableCanvas extends Component<RegionSelectableCanvasProps> {\r\n  private canvas: HTMLCanvasElement\r\n  private canvasCtx: CanvasRenderingContext2D\r\n  private canvasBackup: CanvasBackup\r\n  private canvasRatio: number\r\n\r\n  private originX: number\r\n  private originY: number\r\n  private mouseX: number\r\n  private mouseY: number\r\n\r\n  private selectedAreaStartX: number\r\n  private selectedAreaEndX: number\r\n  private selectedAreaStartY: number\r\n  private selectedAreaEndY: number\r\n\r\n  private mouseIsDown: boolean\r\n\r\n  onRef = (canvas: HTMLCanvasElement) => {\r\n    this.canvas = canvas\r\n    this.canvasCtx = this.canvas.getContext('2d') as CanvasRenderingContext2D\r\n    this.canvasBackup = new CanvasBackup(this.canvas)\r\n    this.canvasRatio = this.canvas.height / this.canvas.width\r\n\r\n    this.props.innerRef(canvas)\r\n  };\r\n\r\n  constructor(props: any) {\r\n    super(props)\r\n    this.canvas = null as any as HTMLCanvasElement\r\n    this.canvasCtx = null as any as CanvasRenderingContext2D\r\n    this.canvasBackup = null as any as CanvasBackup\r\n    this.canvasRatio = null as any as number\r\n    this.originX = 0\r\n    this.originY = 0\r\n    this.mouseX = 0\r\n    this.mouseY = 0\r\n    this.selectedAreaStartX = 0\r\n    this.selectedAreaEndX = 0\r\n    this.selectedAreaStartY = 0\r\n    this.selectedAreaEndY = 0\r\n    this.mouseIsDown = false\r\n  }\r\n\r\n  handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\r\n    this.mouseIsDown = true\r\n    this.originX = e.pageX\r\n    this.originY = e.pageY\r\n  \r\n    this.canvasBackup.save()\r\n  }\r\n\r\n  handleMouseUp = () => {\r\n    this.mouseIsDown = false\r\n    this.props.onChangeSelectedRegion(\r\n      this.selectedAreaStartX,\r\n      this.selectedAreaEndX,\r\n      this.selectedAreaStartY,\r\n      this.selectedAreaEndY\r\n    )\r\n  }\r\n\r\n  calculateSelectionArea () {\r\n    const xWidth = this.mouseX - this.originX;\r\n    const yWidth = this.mouseY - this.originY;\r\n\r\n    const xPreservingAspectRatioWidth = Math.min(xWidth, yWidth / this.canvasRatio)\r\n    const yPreservingAspectRatioHeight = Math.min(yWidth, xWidth * this.canvasRatio)\r\n\r\n    const offsetX = (xWidth - xPreservingAspectRatioWidth) / 2\r\n    const offsetY = (yWidth - yPreservingAspectRatioHeight) / 2\r\n\r\n    const finalWidth = xPreservingAspectRatioWidth\r\n    const finalHeight = yPreservingAspectRatioHeight\r\n\r\n    this.selectedAreaStartX = this.originX + offsetX\r\n    this.selectedAreaStartY = this.originY + offsetY\r\n    this.selectedAreaEndX = this.selectedAreaStartX + finalWidth\r\n    this.selectedAreaEndY = this.selectedAreaStartY + finalHeight\r\n  }\r\n\r\n  handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\r\n    if (this.mouseIsDown) {\r\n      this.mouseX = e.pageX\r\n      this.mouseY = e.pageY\r\n  \r\n      this.calculateSelectionArea()  \r\n      this.canvasBackup.restore()\r\n      this.drawRawRect()\r\n      this.drawFixedRect()\r\n    }\r\n  }\r\n\r\n  drawRawRect() {\r\n    this.drawRect(\r\n      \"#00FF00\",\r\n      this.originX,\r\n      this.mouseX,\r\n      this.originY,\r\n      this.mouseY\r\n    )\r\n  }\r\n\r\n  drawFixedRect () {\r\n    this.drawRect(\r\n      \"#FF0000\",\r\n      this.selectedAreaStartX,\r\n      this.selectedAreaEndX,\r\n      this.selectedAreaStartY,\r\n      this.selectedAreaEndY\r\n    )\r\n  }\r\n\r\n  drawRect(color: string, startX: number, endX: number, startY: number, endY: number) {\r\n    this.canvasCtx.strokeStyle = color;\r\n    this.canvasCtx.strokeRect(startX, startY, endX - startX, endY - startY);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <canvas\r\n        id=\"canvas\"\r\n        ref={this.onRef}\r\n        width={window.innerWidth}\r\n        height={window.innerHeight}\r\n        className={this.props.className}\r\n        onMouseDown={this.handleMouseDown}\r\n        onMouseUp={this.handleMouseUp}\r\n        onMouseMove={this.handleMouseMove}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default RegionSelectableCanvas\r\n","export const sleep = (ms: number) => new Promise(r => setTimeout(r, ms))\r\n","import React, { Component } from \"react\";\r\n\r\nimport classes from './MandelbrotVisualizer.module.css'\r\nimport RegionSelectableCanvas from \"../RegionSelectableCanvas/RegionSelectableCanvas\";\r\n\r\nimport { MandelbrotSet } from '../../domain_wasm/mandelbrot';\r\nimport { sleep } from \"./utils/sleep\";\r\nconst MandelbrotModule = import('../../domain_wasm/mandelbrot')\r\n\r\ninterface MandelbrotVisualizerProps {\r\n  maxIterations: number\r\n  renderingKey: number\r\n  onChangeBounds: (minCornerA: string, minCornerB: string, maxCornerA: string, maxCornerB: string) => void\r\n}\r\n\r\nclass MandelbrotVisualizer extends Component<MandelbrotVisualizerProps> {\r\n  private mandelbrotSet: MandelbrotSet\r\n  private canvasCtx: CanvasRenderingContext2D\r\n\r\n  constructor (props: any) {\r\n    super(props)\r\n\r\n    this.mandelbrotSet = null as any as MandelbrotSet\r\n    this.canvasCtx = null as any as CanvasRenderingContext2D\r\n  }\r\n\r\n  componentDidUpdate (previousProps: MandelbrotVisualizerProps) {\r\n    if(previousProps.renderingKey !== this.props.renderingKey) {\r\n      this.refreshCanvas()\r\n    }\r\n  }\r\n\r\n  onRef = (canvas: HTMLCanvasElement) => {\r\n    this.canvasCtx = canvas.getContext('2d') as CanvasRenderingContext2D \r\n\r\n    MandelbrotModule.then(({ MandelbrotSet }) => {\r\n      this.mandelbrotSet = new MandelbrotSet(canvas.width, canvas.height)\r\n      this.refreshCanvas()\r\n    })    \r\n  };\r\n\r\n  private onChangeSelectedRegion = (startXPx: number, endXPx: number, startYPx: number, endYPx: number) => {\r\n    this.mandelbrotSet.zoom_canvas(startXPx, endXPx, startYPx, endYPx)\r\n    this.refreshCanvas()\r\n  }\r\n\r\n  private async refreshCanvas () {\r\n    this.props.onChangeBounds(\r\n      this.mandelbrotSet.min_corner_a(), \r\n      this.mandelbrotSet.min_corner_b(),\r\n      this.mandelbrotSet.max_corner_a(), \r\n      this.mandelbrotSet.max_corner_b()\r\n    )\r\n    await sleep(50)\r\n    console.time(\"RENDER\")\r\n    this.mandelbrotSet.render(this.canvasCtx, this.props.maxIterations)\r\n    console.timeEnd(\"RENDER\")\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <RegionSelectableCanvas\r\n        innerRef={this.onRef}\r\n        className={classes.canvas}\r\n        onChangeSelectedRegion={this.onChangeSelectedRegion}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default MandelbrotVisualizer\r\n","import * as React from 'react';\r\n\r\nimport classes from './RenderOptions.module.css'\r\n\r\ninterface RenderOptionsProps {\r\n  onChangeMaxIterations: (maxIterations: number) => void\r\n  maxIterations: number\r\n  minCornerA: string\r\n  minCornerB: string\r\n  maxCornerA: string\r\n  maxCornerB: string\r\n  refresh: () => void\r\n}\r\n\r\nexport const RenderOptions: React.SFC<RenderOptionsProps> = ({\r\n  onChangeMaxIterations,\r\n  maxIterations,\r\n  minCornerA,\r\n  minCornerB,\r\n  maxCornerA,\r\n  maxCornerB,\r\n  refresh\r\n}) => (\r\n  <form className={classes.container} onSubmit={e => {\r\n    e.preventDefault()\r\n    refresh()\r\n  }}>\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        value={minCornerA}\r\n      />\r\n      <input\r\n        type=\"text\"\r\n        value={minCornerB}\r\n      />\r\n    </div>\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        value={maxCornerA}\r\n      />\r\n      <input\r\n        type=\"text\"\r\n        value={maxCornerB}\r\n      />\r\n    </div>\r\n    <input\r\n      type=\"number\"\r\n      onChange={e => onChangeMaxIterations(parseInt(e.target.value))}\r\n      value={maxIterations}\r\n    />\r\n    <input type=\"submit\" value=\"Refresh\"/>\r\n  </form>\r\n)\r\n","import React, { Component } from 'react';\nimport MandelbrotVisualizer from './MandelbrotVisualizer/MandelbrotVisualizer';\nimport { RenderOptions } from './RenderOptions/RenderOptions';\n\nclass App extends Component {\n  state = {\n    maxIterations: 100,\n    renderingKey: Math.random(),\n    minCornerA: \"\",\n    minCornerB: \"\",\n    maxCornerA: \"\",\n    maxCornerB: \"\",\n  }\n\n  onChangeMaxIterations = (maxIterations: number) => {\n    this.setState({\n      maxIterations\n    })\n  }\n\n  refresh = () => {\n    this.setState({\n      renderingKey: Math.random()\n    })\n  }\n\n  render() {\n    return (\n      <div>\n        <MandelbrotVisualizer\n          renderingKey={this.state.renderingKey}\n          maxIterations={this.state.maxIterations}\n          onChangeBounds={(minCornerA, minCornerB, maxCornerA, maxCornerB) => this.setState({\n            minCornerA,\n            minCornerB,\n            maxCornerA,\n            maxCornerB\n          })}\n        />\n        <RenderOptions\n          onChangeMaxIterations={this.onChangeMaxIterations}\n          maxIterations={this.state.maxIterations}\n          refresh={this.refresh}\n          minCornerA={this.state.minCornerA}\n          minCornerB={this.state.minCornerB}\n          maxCornerA={this.state.maxCornerA}\n          maxCornerB={this.state.maxCornerB}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}